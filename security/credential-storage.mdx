---
title: 'Credential Storage'
description: 'OS-level keyring storage for secure credential management'
---

# Credential Storage

MiniFy stores all sensitive credentials in your operating system's secure keyring. No credentials are ever written to disk in plaintext or stored on remote servers.

## Storage Architecture

### Keyring Service

All credentials are stored under the service name `"minify"`:

```rust
// spotify_auth.rs:16, ai_keyring.rs:6
const KEYRING_SERVICE: &str = "minify";
```

This allows your OS to group all MiniFy credentials together and manage them as a unit.

### Keyring Entry

Credentials are accessed through the `keyring` Rust crate:

```rust
// spotify_auth.rs:83-85, ai_keyring.rs:23-25
fn entry(key: &str) -> Result<Entry, keyring::Error> {
    Entry::new(KEYRING_SERVICE, key)
}
```

Each credential is identified by a unique key within the `"minify"` service.

## Platform-Specific Storage

MiniFy uses native credential storage on each platform:

<Tabs>
  <Tab title="Windows">
    ### Windows Credential Manager
    
    Credentials are stored in **Windows Credential Manager**, accessible via:
    - Control Panel → User Accounts → Credential Manager → Windows Credentials
    - Look for entries under "Generic Credentials" with target `minify:<key_name>`
    
    **Security Features:**
    - Encrypted using DPAPI (Data Protection API)
    - Protected by your Windows user account
    - Requires your Windows password to access
    - Automatically secured with TPM if available
    
    **Storage Location:**
    ```
    C:\Users\<username>\AppData\Local\Microsoft\Credentials\
    C:\Users\<username>\AppData\Roaming\Microsoft\Credentials\
    ```
    
    <Warning>
    Credentials are accessible to any application running under your Windows user account. Use Windows account security best practices.
    </Warning>
  </Tab>
  
  <Tab title="macOS">
    ### macOS Keychain
    
    Credentials are stored in your **macOS Keychain**, accessible via:
    - Applications → Utilities → Keychain Access
    - Look in the "login" keychain for items named `minify`
    
    **Security Features:**
    - Encrypted with 3DES/AES
    - Protected by your macOS user password
    - Secured by Secure Enclave on supported Macs
    - Can require password for each access (configurable)
    
    **Storage Location:**
    ```
    ~/Library/Keychains/login.keychain-db
    ```
    
    **Access Control:**
    MiniFy is automatically granted access to credentials it creates. You can revoke access in Keychain Access by:
    1. Right-click the credential → Get Info
    2. Access Control tab → Remove "MiniFy" from authorized apps
    
    <Info>
    The keychain locks automatically when your Mac sleeps or after a period of inactivity.
    </Info>
  </Tab>
  
  <Tab title="Linux">
    ### Secret Service API
    
    Credentials are stored using the **Secret Service API**, typically backed by:
    - **GNOME Keyring** (GNOME desktop)
    - **KWallet** (KDE Plasma desktop)
    - Other compatible implementations
    
    **Security Features:**
    - Encrypted using AES
    - Protected by your desktop session password
    - Automatically unlocked when you log in
    - Supports per-item access control
    
    **Storage Locations:**
    
    GNOME Keyring:
    ```
    ~/.local/share/keyrings/
    ```
    
    KWallet:
    ```
    ~/.local/share/kwalletd/
    ```
    
    **Requirements:**
    MiniFy requires a Secret Service provider to be running. Most modern Linux distributions include this by default.
    
    <Warning>
    If no Secret Service provider is available, keyring operations will fail. Install `gnome-keyring` or `kwalletmanager` for your distribution.
    </Warning>
  </Tab>
</Tabs>

## Stored Credentials

### Spotify Credentials

MiniFy stores the following Spotify-related credentials:

<Steps>
  <Step title="Spotify Client ID">
    **Key:** `spotify_client_id`
    
    Your Spotify application client ID. Only stored if you provide a custom client ID (not required for default configuration).
    
    ```rust
    // spotify_auth.rs:21
    const SPOTIFY_CLIENT_ID_KEY: &str = "spotify_client_id";
    ```
  </Step>
  
  <Step title="Access Token">
    **Key:** `access_token`
    
    OAuth access token used to authenticate API requests. Expires after 1 hour.
    
    ```rust
    // spotify_auth.rs:17
    const ACCESS_TOKEN_KEY: &str = "access_token";
    ```
  </Step>
  
  <Step title="Refresh Token">
    **Key:** `refresh_token`
    
    OAuth refresh token used to obtain new access tokens. Doesn't expire unless you revoke access.
    
    ```rust
    // spotify_auth.rs:18
    const REFRESH_TOKEN_KEY: &str = "refresh_token";
    ```
  </Step>
  
  <Step title="Token Expiry">
    **Key:** `token_expiry`
    
    Unix timestamp indicating when the access token expires.
    
    ```rust
    // spotify_auth.rs:19
    const TOKEN_EXPIRY_KEY: &str = "token_expiry";
    ```
  </Step>
  
  <Step title="Music Provider">
    **Key:** `music_provider`
    
    Currently selected music provider (e.g., "spotify").
    
    ```rust
    // spotify_auth.rs:20
    const MUSIC_PROVIDER_KEY: &str = "music_provider";
    ```
  </Step>
</Steps>

### AI Provider API Keys

MiniFy stores API keys for AI providers using a prefixed naming scheme:

```rust
// ai_keyring.rs:7, 19-21
const AI_KEY_PREFIX: &str = "ai_key_";

fn get_ai_key_name(provider: &str) -> String {
    format!("{}{}", AI_KEY_PREFIX, provider)
}
```

**Supported Providers:**
- `ai_key_openai` - OpenAI API key
- `ai_key_anthropic` - Anthropic API key
- `ai_key_google` - Google AI API key
- `ai_key_groq` - Groq API key

## Keyring Operations

### Saving Credentials

All keyring write operations are performed in blocking tasks to avoid blocking the async runtime:

```rust
// ai_keyring.rs:49-69
#[tauri::command]
pub async fn save_ai_api_key(provider: String, api_key: String) -> Result<(), String> {
    if api_key.trim().is_empty() {
        return Err("API key is empty".to_string());
    }
    
    let api_key_trimmed = api_key.trim().to_string();
    let key_name = get_ai_key_name(&provider);
    
    tokio::task::spawn_blocking(move || {
        entry(&key_name)
            .map_err(|e| format!("Keyring error: {}", e))?
            .set_password(&api_key_clone)
            .map_err(|e| format!("Failed to save AI API key: {}", e))
    })
    .await
    .map_err(|e| format!("Task failed: {}", e))?
}
```

### Reading Credentials

Keyring read operations also use blocking tasks and support caching:

```rust
// ai_keyring.rs:71-91
#[tauri::command]
pub async fn get_ai_api_key(provider: String) -> Result<String, String> {
    // Check cache first
    if let Some(cached) = get_cached_ai_key(&provider) {
        return Ok(cached);
    }
    
    // Read from keyring
    let key_name = get_ai_key_name(&provider);
    let result = tokio::task::spawn_blocking(move || {
        entry(&key_name)
            .map_err(|e| format!("Keyring error: {}", e))?
            .get_password()
            .map_err(|e| format!("Failed to get AI API key: {}", e))
    })
    .await
    .map_err(|e| format!("Task failed: {}", e))??;
    
    // Cache for future access
    set_cached_ai_key(&provider_clone, &result);
    Ok(result)
}
```

### Deleting Credentials

Credentials can be deleted individually or all at once:

<Tabs>
  <Tab title="Individual Deletion">
    Delete a single AI provider's API key:
    
    ```rust
    // ai_keyring.rs:116-129
    #[tauri::command]
    pub async fn delete_ai_api_key(provider: String) -> Result<(), String> {
        remove_cached_ai_key(&provider);
        
        let key_name = get_ai_key_name(&provider);
        tokio::task::spawn_blocking(move || {
            entry(&key_name)
                .map_err(|e| format!("Keyring error: {}", e))?
                .delete_password()
                .map_err(|e| format!("Failed to delete AI API key: {}", e))
        })
        .await
        .map_err(|e| format!("Task failed: {}", e))?
    }
    ```
  </Tab>
  
  <Tab title="Bulk Deletion">
    Clear all AI provider API keys:
    
    ```rust
    // ai_keyring.rs:146-163
    #[tauri::command]
    pub async fn clear_all_ai_keys() -> Result<(), String> {
        clear_all_cached_ai_keys();
        
        let providers = vec!["openai", "anthropic", "google", "groq"];
        
        tokio::task::spawn_blocking(move || {
            for p in providers {
                let key_name = get_ai_key_name(p);
                if let Ok(e) = entry(&key_name) {
                    let _ = e.delete_password();
                }
            }
        })
        .await
        .map_err(|e| format!("Task failed: {}", e))?
    }
    ```
  </Tab>
  
  <Tab title="Clear All Credentials">
    Clear all MiniFy credentials (Spotify + AI):
    
    ```rust
    // spotify_auth.rs:300-324
    #[tauri::command]
    pub async fn clear_credentials() -> Result<(), String> {
        clear_cached_client_id();
        clear_cached_tokens();
        clear_cached_music_provider();
        
        tokio::task::spawn_blocking(|| {
            if let Ok(e) = entry(ACCESS_TOKEN_KEY) { let _ = e.delete_password(); }
            if let Ok(e) = entry(REFRESH_TOKEN_KEY) { let _ = e.delete_password(); }
            if let Ok(e) = entry(TOKEN_EXPIRY_KEY) { let _ = e.delete_password(); }
            if let Ok(e) = entry(MUSIC_PROVIDER_KEY) { let _ = e.delete_password(); }
            if let Ok(e) = entry(SPOTIFY_CLIENT_ID_KEY) { let _ = e.delete_password(); }
        }).await
    }
    ```
  </Tab>
</Tabs>

## In-Memory Caching

To minimize keyring access, MiniFy maintains in-memory caches:

### Spotify Token Cache

```rust
// spotify_auth.rs:23-43
lazy_static::lazy_static! {
    static ref CLIENT_ID_CACHE: Arc<Mutex<Option<String>>> = Arc::new(Mutex::new(None));
    static ref TOKENS_CACHE: Arc<Mutex<Option<SpotifyTokens>>> = Arc::new(Mutex::new(None));
    static ref MUSIC_PROVIDER_CACHE: Arc<Mutex<Option<String>>> = Arc::new(Mutex::new(None));
}

fn get_cached_tokens() -> Option<SpotifyTokens> {
    TOKENS_CACHE.lock().ok().and_then(|g| g.clone())
}

fn set_cached_tokens(tokens: &SpotifyTokens) {
    if let Ok(mut cache) = TOKENS_CACHE.lock() {
        *cache = Some(tokens.clone());
    }
}
```

### AI Key Cache

```rust
// ai_keyring.rs:9-41
lazy_static::lazy_static! {
    static ref AI_KEY_CACHE: Arc<Mutex<HashMap<String, String>>> = Arc::new(Mutex::new(HashMap::new()));
}

fn get_cached_ai_key(provider: &str) -> Option<String> {
    AI_KEY_CACHE.lock().ok().and_then(|g| g.get(provider).cloned())
}

fn set_cached_ai_key(provider: &str, key: &str) {
    if let Ok(mut cache) = AI_KEY_CACHE.lock() {
        cache.insert(provider.to_string(), key.to_string());
    }
}
```

<Info>
Caches are stored in process memory only and cleared when the app restarts or when credentials are explicitly cleared.
</Info>

## Security Best Practices

### OS Account Security

<Warning>
Keyring security depends on your OS user account security. Use strong passwords and enable additional security features:

- **Windows:** Use Windows Hello (biometric/PIN) + BitLocker
- **macOS:** Enable FileVault and use strong login password
- **Linux:** Use full-disk encryption (LUKS) and strong login password
</Warning>

### Credential Verification

You can verify which credentials are stored:

```rust
// ai_keyring.rs:93-114
#[tauri::command]
pub async fn has_ai_api_key(provider: String) -> bool {
    if get_cached_ai_key(&provider).is_some() {
        return true;
    }
    
    let key_name = get_ai_key_name(&provider);
    tokio::task::spawn_blocking(move || {
        entry(&key_name).ok().and_then(|e| e.get_password().ok())
    })
    .await
    .ok()
    .flatten()
    .is_some()
}
```

### Manual Credential Management

You can manually view and delete MiniFy credentials using your OS tools:

<Steps>
  <Step title="Windows">
    1. Open **Credential Manager** (Control Panel → User Accounts)
    2. Click **Windows Credentials**
    3. Find entries starting with `minify:`
    4. Click to expand and select **Remove**
  </Step>
  
  <Step title="macOS">
    1. Open **Keychain Access** (Applications → Utilities)
    2. Select the **login** keychain
    3. Search for `minify`
    4. Right-click entries and select **Delete**
  </Step>
  
  <Step title="Linux">
    **GNOME Keyring:**
    ```bash
    # Install seahorse (GUI for keyring management)
    sudo apt install seahorse  # Debian/Ubuntu
    sudo dnf install seahorse  # Fedora
    
    # Launch and search for 'minify'
    seahorse
    ```
    
    **KWallet:**
    ```bash
    # Use KWallet Manager
    kwalletmanager5
    ```
  </Step>
</Steps>

<Note>
Manually deleting credentials will sign you out of MiniFy. You'll need to authenticate again.
</Note>

## Related Documentation

- [Authentication](/security/authentication) - OAuth PKCE flow implementation
- [Privacy Policy](/security/privacy) - Data collection and usage